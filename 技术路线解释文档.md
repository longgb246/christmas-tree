# 圣诞树全息展示项目技术路线详解

## 项目概述

这是一个基于 Web 技术的交互式 3D 圣诞树展示项目，通过摄像头捕捉用户手势，实现手势控制粒子特效的交互体验。项目集成了 3D 渲染、计算机视觉、粒子系统等多种技术。

---

## 核心技术栈

### 1. 3D 渲染引擎
- **Three.js** (v0.160.0)
  - WebGL 渲染核心
  - 场景管理、相机控制、光照系统
  - 后处理效果（Bloom 泛光）

### 2. 计算机视觉
- **MediaPipe Tasks Vision** (v0.10.3)
  - 手部关键点检测
  - 实时手势识别

### 3. 其他技术
- **Import Maps**: 现代 JavaScript 模块导入方案
- **Canvas API**: 动态纹理生成
- **File API**: 照片上传处理

---

## 技术模块详解

### 一、摄像头调用与初始化

#### 1.1 摄像头权限获取
```javascript
const stream = await navigator.mediaDevices.getUserMedia({ video: true });
video.srcObject = stream;
```

**技术要点：**
- 使用 `navigator.mediaDevices.getUserMedia()` API 获取摄像头访问权限
- 返回的 MediaStream 对象绑定到 `<video>` 元素
- 支持 `autoplay` 和 `playsinline` 属性确保视频自动播放

#### 1.2 隐藏的 CV 容器
```html
<div id="cv-container">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="cv-canvas" width="160" height="120"></canvas>
</div>
```

**设计考虑：**
- CV 容器设置为 `opacity: 0`，对用户不可见
- 仅用于计算机视觉处理，不影响视觉体验
- Canvas 用于可能的调试或中间处理

---

### 二、手势捕捉与识别

#### 2.1 MediaPipe HandLandmarker 初始化

```javascript
const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
);

this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
        delegate: "GPU"
    },
    runningMode: "VIDEO",
    numHands: 1
});
```

**技术细节：**
- 使用 WASM (WebAssembly) 加载模型，提升性能
- GPU 加速推理，降低延迟
- `VIDEO` 模式支持实时视频流处理
- 限制检测单只手，优化性能

#### 2.2 实时手势检测循环

```javascript
async predictWebcam() {
    const video = document.getElementById('webcam');
    
    if (STATE.cv.active) {
        let startTimeMs = performance.now();
        const results = this.handLandmarker.detectForVideo(video, startTimeMs);
        
        if (results.landmarks && results.landmarks.length > 0) {
            this.processGestures(results.landmarks[0]);
        }
    }
    
    window.requestAnimationFrame(() => this.predictWebcam());
}
```

**工作流程：**
1. 使用 `requestAnimationFrame` 创建检测循环
2. 每帧调用 `detectForVideo` 获取手部关键点
3. 传递给 `processGestures` 进行手势解析

#### 2.3 手势识别算法

**关键点定义：**
- 0: 手腕 (Wrist)
- 4: 拇指尖 (ThumbTip)
- 8: 食指尖 (IndexTip)
- 9: 手掌中心 (PalmCenter)
- 12, 16, 20: 中指、无名指、小指尖

**三种手势模式：**

##### 1. 捏合手势 (Pinch) - 聚焦模式
```javascript
const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);

if (pinchDist < 0.05) {
    this.switchMode(MODES.FOCUS);
}
```
- 计算拇指与食指尖的欧几里得距离
- 距离小于 0.05 视为捏合
- 触发照片聚焦效果

##### 2. 握拳手势 (Fist) - 树形模式
```javascript
const tips = [8, 12, 16, 20];
let avgDistToWrist = 0;
tips.forEach(i => {
    const tip = landmarks[i];
    avgDistToWrist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
});
avgDistToWrist /= 4;

if (avgDistToWrist < 0.25) {
    this.switchMode(MODES.TREE);
}
```
- 计算四指指尖到手腕的平均距离
- 距离小于 0.25 视为握拳
- 触发粒子组成圣诞树形状

##### 3. 张开手势 (Open Hand) - 散开模式
```javascript
if (avgDistToWrist > 0.4) {
    this.switchMode(MODES.SCATTER);
}
```
- 平均距离大于 0.4 视为张开手掌
- 触发粒子随机散开效果

#### 2.4 手势控制旋转

```javascript
const rotY = (palmCenter.x - 0.5) * 2; 
const rotX = (palmCenter.y - 0.5) * 2;
STATE.cv.rotationTarget.y = rotY; 
STATE.cv.rotationTarget.x = rotX;
```

**映射逻辑：**
- 手掌中心 X 坐标映射到 Y 轴旋转（左右移动控制旋转）
- 手掌中心 Y 坐标映射到 X 轴旋转（上下移动控制倾斜）
- 坐标范围 0-1 映射到 -1 到 1

---

### 三、粒子特效系统

#### 3.1 粒子类型与生成

**粒子数量配置：**
```javascript
const PARTICLE_COUNT = 1500;  // 主粒子
const DUST_COUNT = 2500;      // 背景尘埃
```

**粒子类型分布：**
- 60%: 装饰品（金色方块、红色球体、绿色球体）
- 20%: 糖拐杖（螺旋纹理）
- 20%: 小灯光（白色发光球体）

**材质系统：**
```javascript
const matGold = new THREE.MeshStandardMaterial({ 
    color: 0xd4af37, 
    roughness: 0.3, 
    metalness: 0.8 
});

const matRed = new THREE.MeshPhysicalMaterial({ 
    color: 0xaa0000, 
    roughness: 0.2, 
    metalness: 0.1, 
    clearcoat: 1.0 
});
```

#### 3.2 粒子位置计算

**树形位置算法（螺旋圆锥）：**
```javascript
calculateTreePosition(index, total) {
    const y = -10 + (index / total) * 20;  // 高度范围 -10 到 10
    const radius = 12 * (1 - (index / total));  // 圆锥半径递减
    const angle = index * 0.5;  // 螺旋密度
    
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    
    return new THREE.Vector3(x, y, z);
}
```

**数学原理：**
- Y 轴线性分布，形成垂直高度
- 半径随高度递减，形成圆锥形状
- 角度随索引增加，形成螺旋上升效果

**散开位置算法（球形分布）：**
```javascript
const phi = Math.acos(-1 + (2 * Math.random()));
const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
const r = 8 + Math.random() * 12;

mesh.position.setFromSphericalCoords(r, phi, theta);
```

**数学原理：**
- 使用球坐标系生成均匀分布
- `phi` 和 `theta` 确保球面均匀性
- 半径范围 8-20，形成球形云团

#### 3.3 粒子动画逻辑

**平滑插值系统：**
```javascript
p.mesh.position.lerp(targetPos, 0.05);
p.mesh.scale.lerp(targetScale, 0.05);
```

**三种模式动画：**

##### 1. 树形模式 (TREE)
```javascript
if (STATE.mode === MODES.TREE) {
    targetPos.copy(p.treePos);
    // 螺旋旋转效果
    const offset = time * 0.2;
    const x = targetPos.x * Math.cos(offset) - targetPos.z * Math.sin(offset);
    const z = targetPos.x * Math.sin(offset) + targetPos.z * Math.cos(offset);
    targetPos.set(x, targetPos.y, z);
}
```
- 粒子移动到预计算的树形位置
- 整体围绕 Y 轴缓慢旋转
- 形成动态的圣诞树效果

##### 2. 散开模式 (SCATTER)
```javascript
else if (STATE.mode === MODES.SCATTER) {
    p.basePos.add(p.velocity);
    if(p.basePos.length() > 25) p.velocity.multiplyScalar(-1);
    
    targetPos.copy(p.basePos);
    
    p.mesh.rotation.x += p.velocity.y * 2;
    p.mesh.rotation.y += p.velocity.x * 2;
}
```
- 粒子按随机速度向量移动
- 边界检测，超出范围反弹
- 粒子自转，增加动态感

##### 3. 聚焦模式 (FOCUS)
```javascript
else if (STATE.mode === MODES.FOCUS) {
    if (p === STATE.focusTarget) {
        targetPos.set(0, 2, 35);
        targetScale.set(4.5, 4.5, 4.5);
        p.mesh.lookAt(this.camera.position);
    } else {
        targetPos.copy(p.basePos).multiplyScalar(1.5);
    }
}
```
- 目标照片移动到相机前方 (0, 2, 35)
- 放大 4.5 倍
- 始终面向相机
- 其他粒子向外扩散

#### 3.4 背景尘埃系统

```javascript
const dustGeo = new THREE.BufferGeometry();
const dustPos = [];
for(let i=0; i<DUST_COUNT; i++) {
    const x = (Math.random() - 0.5) * 80;
    const y = (Math.random() - 0.5) * 60;
    const z = (Math.random() - 0.5) * 60;
    dustPos.push(x, y, z);
}
dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
```

**特点：**
- 使用 `BufferGeometry` 优化性能
- 2500 个粒子形成背景星空/雪花效果
- 整体缓慢旋转，营造氛围

---

### 四、照片上传与处理

#### 4.1 文件选择与读取

```javascript
const input = document.getElementById('file-input');
input.addEventListener('change', (e) => {
    if (e.target.files && e.target.files[0]) {
        const f = e.target.files[0];
        const reader = new FileReader();
        
        reader.onload = (ev) => {
            new THREE.TextureLoader().load(ev.target.result, (t) => {
                t.colorSpace = THREE.SRGBColorSpace;
                this.addPhotoToScene(t);
            });
        }
        reader.readAsDataURL(f);
    }
});
```

**处理流程：**
1. 用户点击按钮触发文件选择
2. `FileReader` 读取文件为 Data URL
3. `THREE.TextureLoader` 加载为纹理
4. 设置正确的色彩空间 (SRGB)

#### 4.2 照片帧创建

```javascript
addPhotoToScene(texture) {
    const frameGeo = new THREE.BoxGeometry(4, 4, 0.2);
    const matFrame = new THREE.MeshStandardMaterial({ 
        color: 0xd4af37, 
        roughness: 0.2, 
        metalness: 0.9 
    });
    const matPhoto = new THREE.MeshBasicMaterial({ map: texture });
    
    const mesh = new THREE.Mesh(frameGeo, [matFrame, matFrame, matFrame, matFrame, matPhoto, matFrame]);
    this.addParticle(mesh, 'PHOTO');
}
```

**技术细节：**
- 使用 `BoxGeometry` 创建相框
- 材质数组：6 个面，第 5 个面（正面）显示照片
- 金色边框材质，金属质感
- 标记为 'PHOTO' 类型，用于聚焦模式识别

#### 4.3 默认照片生成

```javascript
createDefaultPhoto() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    ctx.fillStyle = '#fceea7';
    ctx.fillRect(0, 0, 512, 512);
    
    ctx.font = 'bold 60px "Cinzel"';
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('JOYEUX', 256, 200);
    ctx.fillText('NOEL', 256, 280);
    
    ctx.lineWidth = 20;
    ctx.strokeStyle = '#d4af37';
    ctx.strokeRect(10, 10, 492, 492);

    const t = new THREE.CanvasTexture(canvas);
    t.colorSpace = THREE.SRGBColorSpace;
    return t;
}
```

**特点：**
- 使用 Canvas API 动态生成纹理
- 法语 "JOYEUX NOEL"（圣诞快乐）
- 金色边框装饰
- 无需外部图片资源

---

### 五、渲染与后处理

#### 5.1 场景初始化

```javascript
initScene() {
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.toneMapping = THREE.ReinhardToneMapping;
    this.renderer.toneMappingExposure = 2.2;
}
```

**渲染配置：**
- 抗锯齿开启
- 适配设备像素比（Retina 屏支持）
- Reinhard 色调映射，防止过曝
- 曝光度 2.2，增强亮度

#### 5.2 光照系统

```javascript
// 环境光
const ambient = new THREE.AmbientLight(0xffffff, 0.6);

// 中心暖光
const centerLight = new THREE.PointLight(0xffaa00, 2, 50);

// 金色聚光灯
const spotGold = new THREE.SpotLight(0xd4af37, 1200);
spotGold.position.set(30, 40, 40);
spotGold.angle = Math.PI / 6;
spotGold.penumbra = 1;

// 蓝色聚光灯
const spotBlue = new THREE.SpotLight(0x0044ff, 600);
spotBlue.position.set(-30, 20, -30);
```

**光照设计：**
- 环境光提供基础照明
- 中心暖光营造节日氛围
- 金色和蓝色聚光灯形成冷暖对比
- 柔和边缘（penumbra = 1）

#### 5.3 后处理效果

```javascript
initPostProcessing() {
    this.composer = new EffectComposer(this.renderer);
    const renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.45,  // strength - 强度
        0.4,   // radius - 半径
        0.7    // threshold - 阈值
    );
    this.composer.addPass(bloomPass);
}
```

**Bloom 泛光效果：**
- 强度 0.45：适中的发光效果
- 半径 0.4：中等扩散范围
- 阈值 0.7：仅高亮区域发光
- 营造梦幻、全息的视觉效果

#### 5.4 环境映射

```javascript
const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
```

**作用：**
- 提供环境反射
- 增强金属材质的真实感
- PMREM 预过滤，提升渲染性能

---

### 六、交互与 UI

#### 6.1 加载动画

```css
#loader {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: #000;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: opacity 1s ease;
}

.spinner {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(212, 175, 55, 0.3);
    border-top: 4px solid var(--gold);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}
```

**设计：**
- 黑色背景，金色旋转动画
- 模型加载完成后淡出
- 提升用户体验

#### 6.2 UI 控制

```javascript
window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'h') {
        document.getElementById('ui-layer').classList.toggle('ui-hidden');
    }
});
```

**功能：**
- 按 'H' 键隐藏/显示 UI
- 便于截图或纯净观看

#### 6.3 玻璃态按钮

```css
.btn-glass {
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(10px);
    border: 1px solid var(--gold);
    color: var(--gold);
    transition: all 0.3s ease;
}

.btn-glass:hover {
    background: rgba(212, 175, 55, 0.2);
    box-shadow: 0 0 15px var(--gold);
}
```

**视觉风格：**
- 毛玻璃效果（backdrop-filter）
- 金色边框和文字
- 悬停时发光效果

---

## 技术亮点总结

### 1. 性能优化
- 使用 `BufferGeometry` 处理大量粒子
- GPU 加速的手势识别
- 限制检测单只手，降低计算负担
- PMREM 预过滤环境贴图

### 2. 交互设计
- 三种直观的手势控制
- 平滑的插值动画
- 实时响应的手势旋转
- 照片聚焦功能

### 3. 视觉效果
- Bloom 泛光营造梦幻感
- 多种材质组合（金属、物理材质）
- 动态粒子系统
- 冷暖光照对比

### 4. 用户体验
- 加载动画
- 隐藏 UI 功能
- 简洁的照片上传
- 默认内容避免空白

---

## 涉及的核心技术

| 技术领域 | 具体技术 |
|---------|---------|
| 3D 渲染 | Three.js, WebGL, BufferGeometry |
| 计算机视觉 | MediaPipe, HandLandmarker, WASM |
| 图像处理 | Canvas API, TextureLoader, FileReader |
| 动画系统 | Lerp 插值, RequestAnimationFrame |
| 后处理 | EffectComposer, UnrealBloomPass |
| 交互设计 | 手势识别, 文件上传, 键盘事件 |
| 性能优化 | GPU 加速, PMREM, 材质复用 |

---

## 扩展可能性

1. **多手势支持**: 检测双手，实现更复杂的交互
2. **语音控制**: 集成 Web Speech API
3. **更多粒子效果**: 烟花、雪花等
4. **AR 模式**: 使用 WebXR 实现增强现实
5. **多人协作**: WebSocket 实时同步
6. **AI 生成**: 集成 AI 生成个性化装饰

---

## 总结

该项目成功将 3D 图形学、计算机视觉和交互设计融合，创造了一个沉浸式的圣诞主题体验。通过手势控制粒子系统，用户可以直观地与虚拟场景互动，展现了现代 Web 技术的强大能力。
